// This Pine Script® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Sparked0x

//@version=6
indicator("Sparked Beta v.02", shorttitle="Sparked", overlay=true, max_boxes_count=500, max_lines_count=500)

//Todo
// ***SR EDITS***
//Zone age filter → auto-fade or delete zones after n bars.
//Touch count → mark zones that got retested multiple times (stronger).
//Break/flip logic → if price decisively breaks a zone, flip its color to show it as invalid or “flipped support/resistance.”
// Add sensitivity slider for 1m/5m scalping zones (to control how “tight” or “loose” the demand/supply boxes print)?


//RSI EDITS
//RSI Divergence detection → draw lines when price makes new highs but RSI doesn’t (and vice versa).

// ***VWAP EDITS***
// Time options for VWAP resets
//Session VWAP selector → toggle between “entire day,” “session,” or “rolling anchor.”
//Custom deviation profiles → e.g., 0.25, 0.5, 1.0 bands for scalping, 1.5, 2.0 for swing.
//VWAP confluence signals → highlight when EMA200, VWAP, and SD zone overlap (high-probability scalp).

// ***BB EDITS***
// Fix Bollinger Bands not showing on chart

//Visualization
//Toggleable zone styles → filled boxes vs. dashed outlines (for minimal clutter).
//Transparency slider → fade older zones.
//Labels for HTF zones → small text like “1H Supply” or “4H Demand.”

//Automation / Smart features
//Scalp alerts → when price touches a fresh demand zone + RSI oversold + near VWAP band.
//Trend filter → only show demand zones in uptrend, supply in downtrend (avoid counter-trend traps).
//Liquidity sweep detection → wick into a zone with rejection → potential scalp trigger.

// =============================
// === Inputs
// =============================

// Supply/Demand Zones
sdLen      = input.int(20, "Swing Length", minval=1)
sdHTF1     = input.timeframe("60", "Higher TF 1 (zones)")
sdHTF2     = input.timeframe("240", "Higher TF 2 (zones)")
showSD     = input.bool(true, "Show Supply/Demand Zones")
srExtendBars = input.int(5000, "SR Extend Bars", minval=100)
srFullRange  = input.bool(true, "SR Use Full Swing Range")

// EMA
showEMA200 = input.bool(true, "Show EMA 200")

// VWAP + Deviations
showVWAP   = input.bool(false, "Show VWAP + Deviations")
vwapSrc    = input.source(close, "VWAP Source")
vwapDevOn  = input.bool(true, "Show Deviation Bands")
vwapDevSet = input.string("Daily", "VWAP Reset", options=["Session", "Daily", "Weekly", "Monthly"])
devSteps   = input.string("0.5,1,1.5,2", "Deviation Multipliers (comma separated)")

// RSI & Bollinger
showRSI    = input.bool(false, "Overlay RSI signals")
rsiLen     = input.int(14, "RSI Length")
// RSI gradient controls
rsiLowerThr = input.int(30, "RSI Lower Threshold", minval=0, maxval=50)
rsiUpperThr = input.int(70, "RSI Upper Threshold", minval=50, maxval=100)
rsiMaxIntensity = input.int(100, "RSI Max Intensity (0-100)", minval=1, maxval=100)
showBB     = input.bool(false, "Show Bollinger Bands")
bbLen      = input.int(20, "BB Length")
bbMult     = input.float(2.0, "BB Multiplier")

// Trend Oscillator (MACD-style)
showTO     = input.bool(true, "Show Trend Oscillator")
toFastLen  = input.int(34, "TO Fast EMA")
toSlowLen  = input.int(55, "TO Slow EMA")
toSignal   = input.int(9, "TO Signal EMA")

// Visible Range Volume Profile (approximation via lookback)
showVRVP          = input.bool(false, "Show Visible Range Volume Profile")
vrvpLookbackBars  = input.int(200, "VRVP Lookback Bars", minval=10, maxval=5000)
vrvpBins          = input.int(24, "VRVP Price Bins", minval=10, maxval=200)
vrvpMaxWidthBars  = input.int(50, "VRVP Max Width (bars)", minval=5, maxval=200)

// ADR (New York session)
showADR    = input.bool(true, "Show NY Session ADR")
adrLen     = input.int(14, "ADR Length (NY sessions)", minval=1)
nySession  = input.session("0930-1600", "NY Session (chart timezone)")

// =============================
// === Core Logic
// =============================

// EMA200 (high transparency like SR boxes)
ema200 = ta.ema(close, 200)
ema200BaseColor = close > ema200 ? color.red : color.green
ema200Color = color.new(ema200BaseColor, 80)
plot(showEMA200 ? ema200 : na, "EMA 200", color=ema200Color, linewidth=2, display=display.pane)

// VWAP core (built-in)
vwap = ta.vwap(vwapSrc)
plot(showVWAP ? vwap : na, "VWAP", color=color.blue, linewidth=2, display=display.pane)

// VWAP Deviations (std dev bands)
devList = str.split(devSteps, ",")
devStdev = ta.stdev(vwapSrc, 100)

// Safe access for deviation steps
f_getStep(list, idx) =>
    array.size(list) > idx ? str.tonumber(array.get(list, idx)) : na

// Parse deviation steps safely
step0 = f_getStep(devList, 0)
step1 = f_getStep(devList, 1)
step2 = f_getStep(devList, 2)
step3 = f_getStep(devList, 3)

// Plot VWAP deviation bands at root level
plot(showVWAP and vwapDevOn and not na(step0) ? vwap + step0 * devStdev : na, "VWAP +0.5", color=color.new(color.blue, 60), display=display.pane)
plot(showVWAP and vwapDevOn and not na(step0) ? vwap - step0 * devStdev : na, "VWAP -0.5", color=color.new(color.blue, 60), display=display.pane)

plot(showVWAP and vwapDevOn and not na(step1) ? vwap + step1 * devStdev : na, "VWAP +1.0", color=color.new(color.blue, 60), display=display.pane)
plot(showVWAP and vwapDevOn and not na(step1) ? vwap - step1 * devStdev : na, "VWAP -1.0", color=color.new(color.blue, 60), display=display.pane)

plot(showVWAP and vwapDevOn and not na(step2) ? vwap + step2 * devStdev : na, "VWAP +1.5", color=color.new(color.blue, 60), display=display.pane)
plot(showVWAP and vwapDevOn and not na(step2) ? vwap - step2 * devStdev : na, "VWAP -1.5", color=color.new(color.blue, 60), display=display.pane)

plot(showVWAP and vwapDevOn and not na(step3) ? vwap + step3 * devStdev : na, "VWAP +2.0", color=color.new(color.blue, 60), display=display.pane)
plot(showVWAP and vwapDevOn and not na(step3) ? vwap - step3 * devStdev : na, "VWAP -2.0", color=color.new(color.blue, 60), display=display.pane)

// Bollinger Bands
basis = ta.sma(close, bbLen)
dev   = ta.stdev(close, bbLen)
upper = basis + bbMult * dev
lower = basis - bbMult * dev

plot(showBB ? basis : na, "BB Basis", color=color.gray, display=display.pane)
plot(showBB ? upper : na, "BB Upper", color=color.green, display=display.pane)
plot(showBB ? lower : na, "BB Lower", color=color.red, display=display.pane)

// RSI (overlay via barcolor) simple red/green (no transparency)
rsi = ta.rsi(close, rsiLen)
rsiColor = rsi > rsiUpperThr ? color.red : rsi < rsiLowerThr ? color.green : na
barcolor(showRSI ? rsiColor : na)

// =============================
// === Trend Oscillator (MACD-style)
// =============================

toFast = ta.ema(close, toFastLen)
toSlow = ta.ema(close, toSlowLen)
toMacd = toFast - toSlow
toSig  = ta.ema(toMacd, toSignal)
toHist = toMacd - toSig

plot(showTO ? toMacd : na, "TO MACD", color=color.new(color.blue, 0), display=display.pane)
plot(showTO ? toSig  : na, "TO Signal", color=color.new(color.orange, 0), display=display.pane)
plot(showTO ? toHist : na, "TO Hist", style=plot.style_columns, color=toHist >= 0 ? color.new(color.green, 0) : color.new(color.red, 0), display=display.pane)

// =============================
// === Supply/Demand Zones (fractal-based)
// =============================

// =============================
// === ADR (NY Session) - Range and Average of last N sessions
// =============================

// Detect NY session on the chart timeframe
inNY = not na(time(timeframe.period, nySession))
isNYStart = inNY and not inNY[1]
isNYEnd   = not inNY and inNY[1]

// Track current NY session high/low
var float nyHigh = na
var float nyLow  = na

if isNYStart
    nyHigh := high
    nyLow  := low
else if inNY
    nyHigh := na(nyHigh) ? high : math.max(nyHigh, high)
    nyLow  := na(nyLow)  ? low  : math.min(nyLow, low)

// Maintain rolling array of completed NY session ranges
var float[] nyRanges = array.new_float()

if isNYEnd and showADR
    completedRange = nyHigh - nyLow
    if not na(completedRange) and completedRange >= 0
        array.push(nyRanges, completedRange)
        // cap to adrLen
        if array.size(nyRanges) > adrLen
            array.shift(nyRanges)

// Compute ADR = average of nyRanges
f_arrayAvg(arr) =>
    sz = array.size(arr)
    if sz == 0
        na
    else
        total = 0.0
        for i = 0 to sz - 1
            total += array.get(arr, i)
        total / sz

adrValue = f_arrayAvg(nyRanges)
todayNYRange = inNY or isNYEnd ? (nyHigh - nyLow) : na

// Plots for current NY session High/Low
plot(showADR and inNY ? nyHigh : na, "NY Session High", color=color.new(color.purple, 0), linewidth=1)
plot(showADR and inNY ? nyLow  : na, "NY Session Low",  color=color.new(color.purple, 0), linewidth=1)

// Small info table (top-right) with ADR and today's NY range
var table adrTable = table.new(position.top_right, 1, 2)
if barstate.islast and showADR
    hdr = "NY ADR(" + str.tostring(adrLen) + ")"
    val = (na(adrValue) ? "n/a" : str.tostring(adrValue, format.mintick)) + " | Today: " + (na(todayNYRange) ? "n/a" : str.tostring(todayNYRange, format.mintick))
    table.cell(adrTable, 0, 0, hdr, text_color=color.white, text_size=size.small, bgcolor=color.new(color.black, 0))
    table.cell(adrTable, 0, 1, val, text_color=color.white, text_size=size.small, bgcolor=color.new(color.black, 70))

// =============================
// === Visible Range Volume Profile (approximation)
// =============================

var box[] vrvpBoxes = array.new<box>()

f_clearVRVP() =>
    for i = array.size(vrvpBoxes) - 1 to 0
        b = array.get(vrvpBoxes, i)
        box.delete(b)
        array.remove(vrvpBoxes, i)

f_drawVRVP(lookbackBars, bins, maxWidthBars) =>
    canRun = lookbackBars > 0 and bins > 1
    if canRun
        lb = math.min(lookbackBars, bar_index)
        // Determine price range in lookback
        lookHigh = ta.highest(high, lb)
        lookLow  = ta.lowest(low, lb)
        validRange = not na(lookHigh) and not na(lookLow) and lookHigh != lookLow
        if validRange
            step = (lookHigh - lookLow) / bins
            // Avoid divide-by-zero
            if step > 0
                var float[] volBins = array.new_float(bins, 0.0)
                // Accumulate volume per bin
                for i = 0 to lb - 1
                    price = close[i]
                    v = volume[i]
                    idx = math.floor((price - lookLow) / step)
                    idx := idx < 0 ? 0 : idx > bins - 1 ? bins - 1 : idx
                    array.set(volBins, idx, array.get(volBins, idx) + v)
                // Find max volume for normalization
                maxVol = 0.0
                for k = 0 to bins - 1
                    maxVol := math.max(maxVol, array.get(volBins, k))
                if maxVol > 0 and barstate.islast
                    // Clear previous
                    f_clearVRVP()
                    // Draw boxes as horizontal bars
                    leftX = bar_index - lb
                    for k = 0 to bins - 1
                        binLow  = lookLow + k * step
                        binHigh = binLow + step
                        ratio = array.get(volBins, k) / maxVol
                        widthBars = math.floor(ratio * maxWidthBars)
                        if widthBars > 0
                            b = box.new(left=leftX, right=leftX + widthBars, top=binHigh, bottom=binLow, xloc=xloc.bar_index, bgcolor=color.new(color.gray, 80), border_color=na)
                            array.push(vrvpBoxes, b)

if showVRVP
    f_drawVRVP(vrvpLookbackBars, vrvpBins, vrvpMaxWidthBars)

f_swingHigh(len) =>
    high[len] == ta.highest(high, len * 2 + 1)

f_swingLow(len) =>
    low[len] == ta.lowest(low, len * 2 + 1)

var box[] demandZones = array.new<box>()
var box[] supplyZones = array.new<box>()

if showSD
    if f_swingHigh(sdLen)
        zoneHeight = high[sdLen] - low[sdLen]
        if zoneHeight > 0
            topVal = high[sdLen]
            bottomVal = srFullRange ? low[sdLen] : high[sdLen] - zoneHeight / 2
            maxExtend = math.min(srExtendBars, 500)
            newBox = box.new(left=bar_index - sdLen, top=topVal, right=bar_index + maxExtend, bottom=bottomVal, border_color=na, bgcolor=color.new(color.red, 80))
            array.push(supplyZones, newBox)
    if f_swingLow(sdLen)
        zoneHeight = high[sdLen] - low[sdLen]
        if zoneHeight > 0
            topVal = srFullRange ? high[sdLen] : low[sdLen] + zoneHeight / 2
            bottomVal = low[sdLen]
            maxExtend = math.min(srExtendBars, 500)
            newBox = box.new(left=bar_index - sdLen, top=topVal, right=bar_index + maxExtend, bottom=bottomVal, border_color=na, bgcolor=color.new(color.green, 80))
            array.push(demandZones, newBox)

// Clean up old zones when broken (reverse loop to avoid index issues)
if array.size(supplyZones) > 0
    for i = array.size(supplyZones) - 1 to 0
        b = array.get(supplyZones, i)
        if close > box.get_top(b)
            box.delete(b)
            array.remove(supplyZones, i)

if array.size(demandZones) > 0
    for i = array.size(demandZones) - 1 to 0
        b = array.get(demandZones, i)
        if close < box.get_bottom(b)
            box.delete(b)
            array.remove(demandZones, i)

// =============================
// === Higher Timeframe Zones
// =============================

var line[] htfLines = array.new<line>()

f_drawHTFZones(tf, col) =>
    htfHigh = request.security(syminfo.tickerid, tf, high)
    htfLow  = request.security(syminfo.tickerid, tf, low)
    
    // Clean up old lines first
    if array.size(htfLines) > 0
        for i = array.size(htfLines) - 1 to 0
            line.delete(array.get(htfLines, i))
            array.remove(htfLines, i)
    
    // Create new lines
    highLine = line.new(bar_index - 50, htfHigh, bar_index, htfHigh, color=col, extend=extend.right, style=line.style_dashed)
    lowLine = line.new(bar_index - 50, htfLow, bar_index, htfLow, color=col, extend=extend.right, style=line.style_dashed)
    
    array.push(htfLines, highLine)
    array.push(htfLines, lowLine)

if showSD
    f_drawHTFZones(sdHTF1, color.new(color.red, 70))
    f_drawHTFZones(sdHTF2, color.new(color.green, 70))

    //end script
